const sm = {
  version: 3,
  sources: [
    "webpack://@vdocipher/wrapper/../event-bus/src/index.ts",
    "webpack://@vdocipher/wrapper/webpack/bootstrap",
    "webpack://@vdocipher/wrapper/webpack/runtime/define property getters",
    "webpack://@vdocipher/wrapper/webpack/runtime/hasOwnProperty shorthand",
    "webpack://@vdocipher/wrapper/./src/api/api-state.ts",
    "webpack://@vdocipher/wrapper/./src/api/parse-non-primitive.ts",
    "webpack://@vdocipher/wrapper/./src/api/utils.ts",
    "webpack://@vdocipher/wrapper/./src/api/promise-resolver.ts",
    "webpack://@vdocipher/wrapper/./src/api/vdocipher-custom-api.ts",
    "webpack://@vdocipher/wrapper/./src/api/index.ts",
    "webpack://@vdocipher/wrapper/./src/api/get-proxy-video-el.ts",
  ],
  names: [
    "store",
    "on",
    "name",
    "callback",
    "push",
    "index",
    "indexOf",
    "splice",
    "emit",
    "callbacks",
    "onEach",
    "forEach",
    "rest",
    "__webpack_module_cache__",
    "__webpack_require__",
    "moduleId",
    "cachedModule",
    "undefined",
    "exports",
    "module",
    "__webpack_modules__",
    "d",
    "definition",
    "key",
    "o",
    "Object",
    "defineProperty",
    "enumerable",
    "get",
    "obj",
    "prop",
    "prototype",
    "hasOwnProperty",
    "call",
    "ApiState",
    "state",
    "update",
    "newState",
    "getAll",
    "property",
    "TimeRanges",
    "data",
    "this",
    "__store",
    "length",
    "start",
    "end",
    "safeJSONParse",
    "string",
    "JSON",
    "parse",
    "error",
    "PromiseResolver",
    "window",
    "promiseStore",
    "addEventListener",
    "token",
    "type",
    "status",
    "payload",
    "bindPromise",
    "resolveFn",
    "rejectFn",
    "firstPart",
    "secondPart",
    "tokenId",
    "Math",
    "random",
    "toString",
    "slice",
    "settlePromise",
    "source",
    "MessagePort",
    "ServiceWorker",
    "postMessage",
    "stringify",
    "VdocipherCustomAPI",
    "videoEl",
    "eventBus",
    "sendMessage",
    "totalPlayed",
    "totalCovered",
    "totalCoveredArray",
    "_totalPlayedCountLastPos",
    "availableQualities",
    "metaData",
    "value",
    "flooredTime",
    "floor",
    "currentTime",
    "getTotalPlayed",
    "getMetaData",
    "getTotalCovered",
    "getTotalCoveredArray",
    "updatePlayerConfig",
    "config",
    "setCaptionVisibility",
    "setCaptionLanguage",
    "lang",
    "PlayerAPI",
    "iFrame",
    "document",
    "createElement",
    "Promise",
    "resolve",
    "reject",
    "contentWindow",
    "$$payload",
    "param",
    "keys",
    "filter",
    "item",
    "startsWith",
    "argument",
    "parseNonPrimitive",
    "origin",
    "location",
    "result",
    "dispatchEvent",
    "CustomEvent",
    "Array",
    "isArray",
    "proxyVideoEl",
    "commonPrototype",
    "Proxy",
    "target",
    "Function",
    "includes",
    "apply",
    "stateValue",
    "set",
    "getProxyVideoEl",
    "customAPI",
    "video",
    "api",
    "alreadyInitiated",
    "VdoPlayer",
    "Error",
  ],
  mappings:
    "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",
  file: "api.js",
  sourcesContent: [
    "interface EventBusType {\n  on(name: string, callback: (...rest: unknown[]) => void): void;\n  emit(name: string, payload: unknown): void;\n}\nexport default function (): EventBusType {\n  const store: {[key: string]: ((...rest: unknown[]) => void)[]} = {};\n  return {\n    on: function (name, callback) {\n      if (store[name]) {\n        store[name].push(callback);\n      } else {\n        store[name] = [callback];\n      }\n      return () => {\n        const index = store[name].indexOf(callback);\n        if (index > -1) {\n          store[name].splice(index, 1);\n        }\n      };\n    },\n    emit: function (name, ...rest: unknown[]) {\n      const callbacks = store[name];\n      const onEach = store['*'];\n      if (callbacks) {\n        callbacks.forEach((callback) => callback(...rest));\n      }\n      if (onEach) {\n        onEach.forEach((callback) => callback(name, ...rest));\n      }\n    },\n  };\n}\n",
    "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n",
    "// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};",
    "__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }",
    "import {ApiState} from '../../types/api';\n/**\n * Maintain the state for API\n * @return {{updateState: Function, get: Function}}\n */\nexport default function ApiState(): {\n  update: (newState: ApiState) => ApiState;\n  getAll: () => ApiState;\n  get: (property: string) => unknown;\n} {\n  let state: ApiState = {};\n  return {\n    update: (newState: ApiState) => (state = newState),\n    getAll: () => state,\n    get: (property: string) => {\n      return state[property];\n    },\n  };\n}\n",
    "import {PayloadType} from '../../types/api';\n\ninterface TimeRangesConstructor {\n  new (data: number[][]): {\n    state(index: number): number;\n    end(index: number): number;\n  };\n  (data: number[][]): {\n    state(index: number): number;\n    end(index: number): number;\n  };\n}\n\n/**\n * Create the Custom Interface for TimeRange\n * @param {Array} data\n */\nfunction TimeRanges(data: number[][]) {\n  this.__store = data || [];\n  // noinspection JSConstantReassignment\n  this.length = this.__store.length;\n}\n\nTimeRanges.prototype.start = function (index: number) {\n  return this.__store[index][0];\n};\nTimeRanges.prototype.end = function (index: number) {\n  return this.__store[index][1];\n};\n\n/**\n *\n * @param {Object} param\n * @return {Object}\n */\nexport default function parseNonPrimitive(param: {\n  [key: string]: unknown;\n}): PayloadType | undefined {\n  if (!param) return;\n  if (typeof param === 'string') return param;\n  const nonPrimitiveKeys = Object.keys(param).filter((item) =>\n    item.startsWith('$$'),\n  );\n  nonPrimitiveKeys.forEach((key) => {\n    const value = param[key];\n    if (typeof value === 'string') {\n      param[key.slice(2)] = 'NOT_AVAILABLE_ON_API';\n      return delete param[key];\n    }\n    if (typeof value !== 'string') {\n      const {type, argument} = value as {\n        type: string;\n        argument: {data: number[][]};\n      };\n      if (type === 'TimeRanges') {\n        param[key.slice(2)] = new (TimeRanges as TimeRangesConstructor)(\n          argument.data,\n        );\n        return delete param[key];\n      }\n    }\n    param[key.slice(2)] = 'NOT_AVAILABLE_ON_API';\n    return delete param[key];\n  });\n  return param;\n}\n",
    "import {MessageType, PayloadType} from '../../types/api';\n\n/**\n * Safe parse the JSON String\n * @param {String} string\n * @return {Object}\n */\nexport const safeJSONParse = (\n  string: string,\n): {\n  type?: MessageType;\n  status?: boolean;\n  payload?: PayloadType;\n  token?: string;\n} => {\n  try {\n    return JSON.parse(string);\n  } catch (error) {\n    return {};\n  }\n};\n",
    "import {PromiseResolverReturn} from '../../types';\nimport {safeJSONParse} from './utils';\n\n/**\n * Source: https://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js;\n * @return {String}\n */\nfunction generateToken() {\n  // I generate the UID from two parts here\n  // to ensure the random number provide enough bits.\n  const firstPart: string = ((Math.random() * 46656) | 0).toString(36);\n  const secondPart: string = ((Math.random() * 46656) | 0).toString(36);\n  return ('000' + firstPart).slice(-3) + ('000' + secondPart).slice(-3);\n}\n\ninterface PromiseStore {\n  [tokenId: string]: [\n    resolveFn: (payload: unknown) => void,\n    rejectFn: (payload: unknown) => void,\n  ];\n}\n\nexport default function PromiseResolver(window: Window): PromiseResolverReturn {\n  const promiseStore: PromiseStore = {};\n  window.addEventListener('message', ({data}) => {\n    const {token, type, status = true, payload} = safeJSONParse(data);\n    if (type !== '@vdo/promiseResolver' || !token) return;\n    if (token in promiseStore) {\n      status\n        ? promiseStore[token][0](payload)\n        : promiseStore[token][1](payload);\n      delete promiseStore[token];\n    }\n  });\n  return {\n    /**\n     * Attach the promise to promiseResolver\n     * @param {Promise.resolve} resolveFn\n     * @param {Promise.reject} rejectFn\n     * @return {String} tokenId\n     */\n    bindPromise: function (\n      resolveFn: (payload: unknown) => void,\n      rejectFn: (payload: unknown) => void,\n    ) {\n      const tokenId = generateToken();\n      promiseStore[tokenId] = [resolveFn, rejectFn];\n      return tokenId;\n    },\n    /**\n     * Settle the promise for other Iframe\n     * @param {Window} source\n     * @param {string} tokenId\n     * @param {Boolean} status\n     * @param {any} payload\n     */\n    settlePromise: function (\n      source: MessageEventSource,\n      tokenId: string,\n      status = true,\n      payload: unknown,\n    ) {\n      if (\n        !(source instanceof MessagePort) &&\n        !(source instanceof ServiceWorker)\n      ) {\n        source.postMessage(\n          JSON.stringify({\n            type: '@vdo/promiseResolver',\n            token: tokenId,\n            status,\n            payload,\n          }),\n          '*',\n        );\n      }\n    },\n  };\n}\n",
    "import {EventBusConstructor} from '../../types/api';\nimport {\n  VdocipherCustomAPI,\n  PlayerConfiguration,\n  MetaData,\n} from '../../types/api.type';\n/**\n *\n * @param {HTMLVideoElement} videoEl\n * @param {EventBus} eventBus\n * @param {Function} sendMessage\n * @return {{\n *  getTotalPlayed: Function,\n *  getTotalCoveredArray: Function\n * }}\n */\nexport default function VdocipherCustomAPI(\n  videoEl: HTMLVideoElement,\n  eventBus: InstanceType<EventBusConstructor>,\n  sendMessage: (\n    type: string,\n    name?: string | null | symbol,\n    payload?: unknown,\n  ) => Promise<boolean>,\n): VdocipherCustomAPI {\n  const state = {\n    totalPlayed: 0,\n    totalCovered: 0,\n    totalCoveredArray: [] as number[],\n    _totalPlayedCountLastPos: 0,\n    availableQualities: [],\n    metaData: undefined as undefined | MetaData,\n  };\n\n  eventBus.on('availableQualities', (availableQualities) => {\n    state.availableQualities = availableQualities;\n  });\n\n  eventBus.on('_metaDataLoadSuccess', (value) => {\n    state.metaData = value;\n  });\n\n  videoEl.addEventListener('timeupdate', function () {\n    const flooredTime = Math.floor(videoEl.currentTime);\n    if (flooredTime === state._totalPlayedCountLastPos + 1) {\n      state.totalPlayed++;\n      state._totalPlayedCountLastPos = flooredTime;\n\n      if (!state.totalCoveredArray[flooredTime]) {\n        state.totalCovered++;\n        state.totalCoveredArray[flooredTime] = 1;\n      } else {\n        state.totalCoveredArray[flooredTime]++;\n      }\n    } else if (flooredTime !== state._totalPlayedCountLastPos) {\n      state._totalPlayedCountLastPos = flooredTime;\n    }\n  });\n  return {\n    getTotalPlayed: () => state.totalPlayed,\n    getMetaData: () => state.metaData,\n    getTotalCovered: () => state.totalCovered,\n    getTotalCoveredArray: () => state.totalCoveredArray,\n    updatePlayerConfig: (config: PlayerConfiguration) =>\n      sendMessage('@vdo/eventBus', null, {\n        name: 'updatePlayerConfig',\n        data: config,\n      }),\n    setCaptionVisibility: (status: boolean) =>\n      sendMessage('@vdo/eventBus', null, {\n        name: 'setCaptionVisibility',\n        data: status,\n      }),\n    setCaptionLanguage: (lang: string) =>\n      sendMessage('@vdo/eventBus', null, {\n        name: 'setCaptionLang',\n        data: lang,\n      }),\n  };\n}\n",
    "/* eslint-disable no-invalid-this */\n/* eslint-disable no-undef */\nimport EventBus from '@vdocipher/event-bus';\nimport {\n  PromiseResolverConstructor,\n  VdocipherCustomAPIConstructor,\n  ApiStateConstructor,\n  EventBusConstructor,\n} from '../../types/api';\n\nimport {PlayerAPIConstructor} from '../../types/api.type';\nimport ApiState from './api-state';\nimport getProxyVideoEl from './get-proxy-video-el';\nimport parseNonPrimitive from './parse-non-primitive';\nimport PromiseResolver from './promise-resolver';\nimport {safeJSONParse} from './utils';\nimport VdocipherCustomAPI from './vdocipher-custom-api';\n\n/**\n *\n * @param {HTMLIFrameElement} iFrame\n * @return {Object}\n */\nfunction PlayerAPI(iFrame: HTMLIFrameElement) {\n  const state = new (ApiState as ApiStateConstructor)();\n  const eventBus = new (EventBus as EventBusConstructor)();\n  const videoEl = document.createElement('video');\n  const {bindPromise, settlePromise} =\n    new (PromiseResolver as PromiseResolverConstructor)(window);\n\n  const sendMessage = (\n    type: string,\n    name?: string | null | symbol,\n    payload?: unknown,\n  ) =>\n    new Promise((resolve, reject) => {\n      const token = bindPromise(resolve, reject);\n      iFrame.contentWindow &&\n        iFrame.contentWindow.postMessage(\n          JSON.stringify({\n            name,\n            type,\n            token,\n            payload: payload === undefined ? [] : payload,\n          }),\n          '*',\n        );\n      bindPromise(resolve, reject);\n    });\n\n  window.addEventListener('message', ({data, source}) => {\n    const {type, payload: $$payload, token} = safeJSONParse(data); // JSON.parse(data);\n    const payload = parseNonPrimitive($$payload as {[key: string]: unknown});\n\n    if (type === '@vdo/readyToHandshake') {\n      sendMessage('@vdo/handshake', null, {origin: window.location.origin});\n    }\n    if (type === '@vdo/element/event') {\n      if (typeof payload !== 'string' || !source) return;\n      const result = videoEl.dispatchEvent(new CustomEvent(payload));\n      if (token) settlePromise(source, token, result);\n    }\n    if (type === '@vdo/updateState') {\n      if (payload && typeof payload !== 'string' && !Array.isArray(payload))\n        state.update(payload);\n      if (token && source) settlePromise(source, token);\n    }\n    if (type === '@vdo/eventBus') {\n      if (\n        typeof payload !== 'string' &&\n        payload &&\n        'name' in payload &&\n        typeof payload.name === 'string' &&\n        'data' in payload\n      ) {\n        eventBus.emit(payload.name, payload.data);\n      }\n      // eventBus.emit(payload.name);\n    }\n  });\n\n  sendMessage('@vdo/handshake');\n  const proxyVideoEl = getProxyVideoEl({videoEl, iFrame, state, sendMessage});\n  const customAPI = new (VdocipherCustomAPI as VdocipherCustomAPIConstructor)(\n    proxyVideoEl,\n    eventBus,\n    sendMessage,\n  );\n\n  return {\n    video: proxyVideoEl,\n    api: {...customAPI},\n  };\n}\n\nexport const VdoPlayer = (function () {\n  const alreadyInitiated = [] as HTMLIFrameElement[];\n  return function (iFrame: HTMLIFrameElement) {\n    if (alreadyInitiated.includes(iFrame))\n      throw new Error(\n        '[VdoCipher] (API) Cannot create multiple instance from same Iframe',\n      );\n    alreadyInitiated.push(iFrame);\n    return new (PlayerAPI as PlayerAPIConstructor)(iFrame);\n  };\n})();\n\nwindow.VdoPlayer = VdoPlayer;\n",
    "import {HTMLVideoElementProperties} from '../../types';\nimport {ApiStateConstructor} from '../../types/api';\n\ninterface param {\n  videoEl: HTMLVideoElement;\n  iFrame: HTMLIFrameElement;\n  state: InstanceType<ApiStateConstructor>;\n  sendMessage: (\n    type: string,\n    name?: string | null | symbol,\n    payload?: unknown,\n  ) => void;\n}\n/**\n * Return the proxy videoEl;\n * @param {{\n *   videoEl: HTMLVideoElement,\n *   ifFrame: HTMLIFrameElement,\n *   state: state,\n *   sendMessage: Function\n * }} param\n * @return {ProxyHandler}\n */\nexport default function getProxyVideoEl({\n  videoEl,\n  state,\n  sendMessage,\n}: param): HTMLVideoElement {\n  const commonPrototype = ['addEventListener'];\n  return new Proxy(videoEl, {\n    get(target, key) {\n      if (key === 'target') return target;\n      const value = videoEl[key as keyof HTMLVideoElement];\n      const isMethod = value instanceof Function;\n      if (isMethod) {\n        return function (...rest: never[]) {\n          if (commonPrototype.includes(key as string)) {\n            value.apply(videoEl, rest);\n            sendMessage('@vdo/element/event', key, rest);\n          } else {\n            return sendMessage('@vdo/element/method', key, rest);\n          }\n        };\n      } else {\n        const stateValue = state.get(key as string);\n        return stateValue === undefined ? value : stateValue;\n      }\n    },\n    set(target, key, value) {\n      sendMessage('@vdo/element/property', key, value);\n      videoEl[key as keyof HTMLVideoElementProperties] = value as never;\n      return true;\n    },\n  });\n}\n",
  ],
  sourceRoot: "",
};

module.exports = sm;
